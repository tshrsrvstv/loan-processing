import os

import imblearn
from docutils.nodes import label
from imblearn.over_sampling import SMOTE
from keras import metrics
from sklearn.metrics import confusion_matrix, classification_report, roc_auc_score, roc_curve
from sklearn.model_selection import train_test_split
import keras
from keras.models import Sequential
from keras.layers import Dense, Activation
from keras.callbacks import EarlyStopping
from keras.utils import to_categorical
from matplotlib import pyplot as plt
from keras.metrics import categorical_accuracy

from model.Constants import VISUALIZATION_SAVE_DIRECTORY
from model.DataFrameHandler import DataFrameHandler
from model.Logger import logger
from model.PrePocessor import PreProcessor
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


def main():
    logger.info('In NeuralNetworkModel | Main Started')
    pre_process = PreProcessor()
    df = pre_process.load_data()
    df_handler = DataFrameHandler(df)
######################################################################################################################
#  Model 1: Dummy Encoding for Categorical Variables-> MinMax Scaling for Numerical Variables                        #
######################################################################################################################
    dummies_df = df_handler.get_dummies_data()
    logger.debug(dummies_df.head())
    scaled_df = df_handler.get_scaled_data(df=dummies_df)
    attribute_target_split_result = df_handler.split_attribute_and_target(df=scaled_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    y = pd.get_dummies(y, prefix=df_handler.target_col)
    logger.debug(X.head())
    logger.debug(y)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 2: Dummy Encoding for Categorical Variables-> MinMax Scaling for Numerical Variables-> SMOTE on training Set#
######################################################################################################################
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    sm = SMOTE(random_state=42)
    X_train, y_train = sm.fit_resample(X_train, y_train)
    y_train = pd.get_dummies(y_train, prefix=df_handler.target_col)
    y_test = pd.get_dummies(y_test, prefix=df_handler.target_col)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model2_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model2_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model2_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 3: Dummy Encoding for Categorical Variables-> SMOTE on training Set                                         #
######################################################################################################################
    attribute_target_split_result = df_handler.split_attribute_and_target(df=dummies_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    sm = SMOTE(random_state=42)
    X_train, y_train = sm.fit_resample(X_train, y_train)
    y_train = pd.get_dummies(y_train, prefix=df_handler.target_col)
    y_test = pd.get_dummies(y_test, prefix=df_handler.target_col)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model3_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model3_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model3_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 4: Dummy Encoding for Categorical Variables                                                                 #
######################################################################################################################
    attribute_target_split_result = df_handler.split_attribute_and_target(df=dummies_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    y = pd.get_dummies(y, prefix=df_handler.target_col)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model4_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model4_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model4_roc_auc'))
    plt.pause(1)
    plt.close()
    del model

######################################################################################################################
#  Model 5: Dummy Encoding for Categorical Variables-> Binning for Numerical Variables                               #
######################################################################################################################
    dummies_df = df_handler.get_dummies_data()
    logger.debug(dummies_df.head())
    binned_df = df_handler.get_binned_data(df=dummies_df)
    attribute_target_split_result = df_handler.split_attribute_and_target(df=binned_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    y = pd.get_dummies(y, prefix=df_handler.target_col)
    logger.debug(X.head())
    logger.debug(y)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model5_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model5_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model5_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 6: Dummy Encoding for Categorical Variables-> Binning for Numerical Variables-> SMOTE on training Set       #
######################################################################################################################
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    sm = SMOTE(random_state=42)
    X_train, y_train = sm.fit_resample(X_train, y_train)
    y_train = pd.get_dummies(y_train, prefix=df_handler.target_col)
    y_test = pd.get_dummies(y_test, prefix=df_handler.target_col)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model6_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model6_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model6_roc_auc'))
    plt.pause(1)
    plt.close()
    del model

######################################################################################################################
#  Model 7: Label Encoding for Categorical Variables-> MinMax Scaling for Numerical Variables                        #
######################################################################################################################
    label_df = df_handler.get_label_encoded_data()
    logger.debug(label_df.head())
    scaled_df = df_handler.get_scaled_data(df=label_df)
    attribute_target_split_result = df_handler.split_attribute_and_target(df=scaled_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    y = pd.get_dummies(y, prefix=df_handler.target_col)
    logger.debug(X.head())
    logger.debug(y)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model7_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model7_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model7_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 8: Label Encoding for Categorical Variables-> MinMax Scaling for Numerical Variables-> SMOTE on training Set#
######################################################################################################################
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    sm = SMOTE(random_state=42)
    X_train, y_train = sm.fit_resample(X_train, y_train)
    y_train = pd.get_dummies(y_train, prefix=df_handler.target_col)
    y_test = pd.get_dummies(y_test, prefix=df_handler.target_col)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model8_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model8_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model8_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 9: Label Encoding for Categorical Variables-> SMOTE on training Set                                         #
######################################################################################################################
    attribute_target_split_result = df_handler.split_attribute_and_target(df=label_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    sm = SMOTE(random_state=42)
    X_train, y_train = sm.fit_resample(X_train, y_train)
    y_train = pd.get_dummies(y_train, prefix=df_handler.target_col)
    y_test = pd.get_dummies(y_test, prefix=df_handler.target_col)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model9_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model9_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model9_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 10: Label Encoding for Categorical Variables                                                                 #
######################################################################################################################
    attribute_target_split_result = df_handler.split_attribute_and_target(df=label_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    y = pd.get_dummies(y, prefix=df_handler.target_col)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model10_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model10_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model10_roc_auc'))
    plt.pause(1)
    plt.close()
    del model

######################################################################################################################
#  Model 11: Label Encoding for Categorical Variables-> Binning for Numerical Variables                               #
######################################################################################################################
    label_df = df_handler.get_label_encoded_data()
    logger.debug(label_df.head())
    binned_df = df_handler.get_binned_data(df=label_df)
    attribute_target_split_result = df_handler.split_attribute_and_target(df=binned_df)
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    y = pd.get_dummies(y, prefix=df_handler.target_col)
    logger.debug(X.head())
    logger.debug(y)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model11_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model11_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model11_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
######################################################################################################################
#  Model 12: Label Encoding for Categorical Variables-> Binning for Numerical Variables-> SMOTE on training Set       #
######################################################################################################################
    X = attribute_target_split_result['attributes']
    y = attribute_target_split_result['target']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    sm = SMOTE(random_state=42)
    X_train, y_train = sm.fit_resample(X_train, y_train)
    y_train = pd.get_dummies(y_train, prefix=df_handler.target_col)
    y_test = pd.get_dummies(y_test, prefix=df_handler.target_col)
    colnum = X_train.shape[1]
    model = Sequential()
    model.add(Dense(150, activation='relu', input_shape=(colnum,)))
    model.add(Dense(100, activation='relu', input_shape=(colnum,)))
    model.add(Dense(50, activation='relu', input_shape=(colnum,)))
    model.add(Dense(2, activation='softmax'))
    logger.debug(model.summary())
    model.compile(optimizer='adamax',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    logger.debug(model.metrics_names)
    history = model.fit(X_train, y_train, epochs=45)
    score = model.evaluate(X_test, y_test, verbose=0)
    logger.debug(score)
    plt.plot(np.arange(0, len(history.history['loss'])), history.history['loss'])
    plt.title("Loss")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model12_losses'))
    plt.pause(1)
    plt.close()
    plt.plot(np.arange(0, len(history.history['accuracy'])), history.history['accuracy'])
    plt.title("Accuracy")
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model12_accuracy'))
    plt.pause(1)
    plt.close()
    y_pred = model.predict(X_test)
    logger.debug(y_pred)
    rounded_predictions = model.predict_classes(X_test)
    logger.debug(rounded_predictions)
    print('Confusion Matrix: ')
    print(confusion_matrix(y_test['target_yes'], rounded_predictions))
    print('Classification Report: ')
    print(classification_report(y_test['target_yes'], rounded_predictions))
    probs = model.predict_proba(X_test)
    probs = probs[:, 1]
    auc = roc_auc_score(y_test['target_yes'], probs)
    print('AUC: %.2f' % auc)
    fpr, tpr, thresholds = roc_curve(y_test['target_yes'], probs)
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.grid()
    plt.ion()
    plt.show()
    plt.savefig(os.path.join(VISUALIZATION_SAVE_DIRECTORY, 'nn_model12_roc_auc'))
    plt.pause(1)
    plt.close()
    del model
    logger.info('In NeuralNetworkModel | Main Finished')


if __name__ == '__main__':
    main()
